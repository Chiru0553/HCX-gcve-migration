locals {

  # Map configuration parameters for each instance to be deployed
  pavm_values = { for name, config in var.vmconfig : name => {
    vm_name        = config.name
    num_cpus       = config.cpus
    memory         = config.memory
    folder         = config.folder
    remote_ovf_url = config.remote_ovf
    }
  }

  # Helper Map to access each network_interface value for each instance
  netint_map = merge([
      for vmtype, values in var.vmconfig:
      {
        for netint in values.netint:
          "${vmtype}-${netint}" => {vmtype = vmtype, netint = netint}
      }
    ]...)
}

# Create multiple vsphere_network data sources from netint_map
data "vsphere_network" "nicint" {
   for_each         = local.netint_map
   name             = each.value.netint
   datacenter_id    = data.vsphere_datacenter.dc.id
}

# Create vmWare instance(s) as per pavm_values
resource "vsphere_virtual_machine" "vm" {
  for_each        = local.pavm_values
  name            = each.value.vm_name
  num_cpus        = each.value.num_cpus
  memory          = each.value.memory
  folder          = each.value.folder
  resource_pool_id = data.vsphere_resource_pool.pool.id
  datastore_id     = data.vsphere_datastore.datastore.id
  datacenter_id    = data.vsphere_datacenter.dc.id
  host_system_id   = data.vsphere_host.host.id

  wait_for_guest_net_timeout = 0
  wait_for_guest_ip_timeout  = 0

  # Use remote OVF file to initialize default parameters
  ovf_deploy {
    remote_ovf_url    = each.value.remote_ovf_url
    disk_provisioning = ""
    ovf_network_map = {
      "VM Network" = data.vsphere_network.pa-network-mgmt.id
    }
  }  

  # Dynamic network interface block to allow arbitrary amount (max 10) of NICs for each instance
  dynamic "network_interface" {
    for_each = data.vsphere_network.nicint
    content {
      network_id = network_interface.value.id
    }
  }
}
